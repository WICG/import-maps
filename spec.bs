<pre class="metadata">
Title: Import Maps
Shortname: import-maps
Repository: WICG/import-maps
Inline Github Issues: true
Group: WICG
Status: ED
Level: 1
URL: https://wicg.github.io/import-maps/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: Import maps allow web pages to control the behavior of JavaScript imports, and introduce a new <code>import:</code> URL scheme to allow using this mapping in other URL-accepting contexts
!Participate: <a href="https://github.com/WICG/import-maps">GitHub WICG/import-maps</a> (<a href="https://github.com/WICG/import-maps/issues/new">new issue</a>, <a href="https://github.com/WICG/import-maps/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/import-maps/commits/master/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
</pre>
<pre class="link-defaults">
spec: infra; type: dfn
  text: string
  text: list
spec: url; type: dfn; for: /; text: url
spec:infra; type:dfn; for:/; text:starts with
</pre>
<pre class="anchors">
spec: html; type: dfn; urlPrefix: https://html.spec.whatwg.org/multipage/
  text: module map; for: /; url: webappapis.html#module-map
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

summary {
  cursor: pointer;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="definitions">Definitions</h2>

A <dfn>specifier map</dfn> is an [=ordered map=] from [=strings=] to [=lists=] of [=URLs=].

<!-- TODO: unexport these; only doing that for now to un-break the build in our intermediate state. -->

A <dfn>import map</dfn> is a [=struct=] with two [=struct/items=]:

* <dfn for="import map" export>imports</dfn>, a [=specifier map=], and
* <dfn for="import map" export>scopes</dfn>, an [=ordered map=] of [=URLs=] to [=specifier maps=].

<h2 id="acquiring">Acquiring import maps</h2>

<h3 id="integration-environment-settings-object">New members of environment settings object</h3>

Each environment settings object has an [=/import map=] <dfn for="environment settings object">import map</dfn>.
It is initially null.

<p class="note">This returns an [=/import map=] created by parsing and merging all
`<script type="importmap">` elements that are encountered (before the cutoff).
</p>

<p class="note">Alternatives: We might want to associate import maps with e.g.
[=environment settings object/module map=], realm, etc.
So far I don't have any specific pros/cons for these options.</p>

Each environment settings object has an integer,
<dfn for="environment settings object">pending import maps count</dfn>.
It is initially 0.

Each environment settings object has a boolean,
<dfn for="environment settings object">acquiring import maps flag</dfn>.
It is initially true.

<p class="note">These two flags are used to achieve the following behavior:
(1) Import maps are accepted if and only if they are added
(i.e. their corresponding script elements are added)
before the first module loading is started,
even if the loading of the import map files don't finish
before the first module loading is started.
(2) Module loading waits for already started import maps loading, if any.
</p>

<h3 id="integration-prepare-a-script">Prepare a script</h3>

- <a spec="html">the script's type</a> should be:
    - which is either "classic", "module", or "importmap".
  <p class="note">Although we add the third script type,
  we don't add the third subclass of
  <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-script">script</a>.
  Import maps are processed outside the existing paths for
  <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-script">script</a>s
  and their <a spec="html">execute a script block</a>,
  because the mechanism controlling the orders/dependencies
  between import map registration and script evaluation
  is quite separeted and different from the mechanism
  for controlling script evaluation order.
  </p>
- Insert the following step to <a spec="html">prepare a script</a> Step 7,
  under "Determine the script's type as follows:":
    - If the script block's type string is an
      <a spec="infra">ASCII case-insensitive</a> match for the string
      "importmap", <a spec="html">the script's type</a> is "importmap".
- Insert the following step
  before <a spec="html">prepare a script</a> Step 24:
    - If <a spec="html">the script's type</a> is "importmap" and
      |settings object|'s
      [=environment settings object/acquiring import maps flag=] is false,
      then queue a task to fire an event named error at the element,
      and return.
      <p class="note">
      Alternative considered:
      We can proceed to import map loading if
      [=environment settings object/pending import maps count=] isn't 0,
      even when [=environment settings object/acquiring import maps flag=]
      is false,
      because at that time subsequent module loading is blocked and
      new import maps loading can be still added.
      This would allow a little more opportinities for adding import maps,
      but this would highly depend on the timing of network loading.
      For example, if the preceding import map loading finishes earlier
      than expected, then subsequent import maps depending on this behavior
      might fail.
      To avoid this kind of nondeterminism,
      I didn't choose this option, unless there are specific needs.
      </p>
- Insert the following before <a spec="html">prepare a script</a> Step 24.6:
    - If <a spec="html">the script's type</a> is "importmap", then:
        1. Increment |settings object|'s
           [=environment settings object/pending import maps count=].
        1. <a>Fetch an import map</a> given <var ignore>url</var>, |settings object|, and <var ignore>options</var>.
        1. When the previous step asynchronously completes:
            1. Decrement |settings object|'s
               [=environment settings object/pending import maps count=].
               This should unblock [=wait for import maps=] algorithms
               asynchronously when
               [=environment settings object/pending import maps count=]
               becomes 0.
               <p class="issue">Spec this more formally.</p>
            1. If the result if a failure, queue a task to fire
               an event named error at the element, and return.
            1. <a>Register an import map</a> given the result,
               |settings object|, |base URL|, and the element.
        1. Return.
- Insert the following before <a spec="html">prepare a script</a> Step 25.2:
    - If <a spec="html">the script's type</a> is "importmap", then:
        1. <a>Register an import map</a>
           given <var ignore>source text</var>, |settings object|,
           |base URL|, and the element.
           <p class="note">CSP is already applied in Step 13 of
           <a spec="html">prepare a script</a>, just like an inline script.</p>
        1. Return.

<p class="issue">CSP is applied to import maps just like scripts.
Is it sufficient?
<a href="https://github.com/WICG/import-maps/issues/105">Issue #105</a></p>

<p class="note">The script never becomes
<a spec="html" lt="the script is ready">ready</a> and
<a spec="html">the script's script</a> remains null.</p>

<div algorithm>
To <dfn export>fetch an import map</dfn> given <var ignore>url</var>,
<var ignore>settings object</var>, and <var ignore>options</var>:

1. <p class="note">TODO: Implement external import map fetching.
   This asynchronously returns a string or a failure.</p>

<p class="note">CSP is to be applied in the Fetch spec.</p>

</div>

<h3 id="integration-wait-for-import-maps">Wait for import maps</h3>

<div algorithm>
To <dfn export>wait for import maps</dfn> given |settings object|,
run these steps.

1. If |settings object|'s
   [=environment settings object/acquiring import maps flag=] is false, then
   asynchronously complete the algorithm with a failure.
1. Block while |settings object|'s
   [=environment settings object/pending import maps count=] is not 0.
1. Set |settings object|'s
   [=environment settings object/acquiring import maps flag=] to false.
1. Asynchronously complete the algorithm with a success.

</div>

Insert a call to [=wait for import maps=] at the beginning of the following HTML spec concepts,
and complete the algorithms with a failure when [=wait for import maps=] completes with a failure.

- <a spec="html">fetch a module script graph</a>
- fetch a dynamic module script graph
- fetch an inline module script graph
- <a spec="html">fetch a module worker script graph</a> using
  <var ignore>module map settings object</var>

Insert a call to [=wait for import maps=] before Step 11
(a call to <a spec="html">fetch a single module script</a>) of
<a spec="html">fetch and process the linked resource</a> algorithm for modulepreload links, and
skip Step 11 and set <var ignore>result</var> to null
when [=wait for import maps=] completes with a failure.

<p class="advisement">
In the current HTML-based spec,
the settings object used here is |module map settings object|,
not fetch client settings object, because
[=resolve a module specifier=] uses
the import map of |module map settings object|.
In fetch-spec-based import map, this would be
<var ignore>fetch client settings object</var> instead.
This only affects <a spec="html">fetch a module worker script graph</a>
where these two settings objects are different.
</p>

<p class="advisement">Depending on the exact location of
[=wait for import maps=], there would be observable behavior differences
between HTML- and Fetch-based import maps.
For example, the current HTML-spec-based draft here calls
[=wait for import maps=] at very early stages of module loading before
[=resolve a module specifier=]. Therefore,
[=environment settings object/acquiring import maps flag=] is always
cleared, even if [=resolve a module specifier=] fails e.g. in parsing
http://:invalid.
When we switch to Fetch-spec-based, import map resolution would be
done inside Fetch spec after [=resolve a module specifier=] and thus
we might also want to [=wait for import maps=] after
[=resolve a module specifier=].
In that case,
[=environment settings object/acquiring import maps flag=] wouldn't
be cleared for http://:invalid, because we early-exit module loading.
</p>

<h3 id="integration-register-an-import-map">Registering an import map</h3>

<div algorithm>
To <dfn>register an import map</dfn> given a [=string=] |source text|,
|settings object|, a [=URL=] |base URL|, and an [=/Element=] |element|,
run the following steps.

1. <p class="issue">Should we check whether the script element is moved
   across documents?
   Currently, we don't check that and the import maps are always registered
   to the settings object at the time of prepare-a-script.</p>
1. Let |import map| be the result of <a>parse an import map string</a>,
   given |source text| and |base URL|.
1. If |import map| is null:
    1. Queue a task to fire an event named `error` at |element|.
1. Else if |settings object|'s
   [=environment settings object/import map=] is null, then:
    1. Set |settings object|'s
       [=environment settings object/import map=] to |import map|.
1. Else:
    1. <a>Merge import maps</a>,
       given |settings object|'s [=environment settings object/import map=]
       and |import map|.

</div>

<div algorithm>
To <dfn>merge import maps</dfn>, given an [=/import map=] |import map| and
an [=/import map=] |new import map|:

1. Assert: |import map| is not null.
1. Assert: |new import map| is not null.
1. <p class="note">TODO: Implement merging. This modifies |import map| in-place.</p>

</div>

<h2 id="parsing">Parsing import maps</h2>

<div algorithm>
  To <dfn>parse an import map string</dfn>, given a [=string=] |input| and a [=URL=] |baseURL|:

  1. Let |parsed| be the result of [=parse JSON into Infra values|parsing JSON into Infra values=] given |input|.
  1. If |parsed| is not a [=map=], then throw a {{TypeError}} indicating that the top-level value must be a JSON object.
  1. Let |sortedAndNormalizedImports| be an empty [=map=].
  1. If |parsed|["`imports`"] [=map/exists=], then:
    1. If |parsed|["`imports`"] is not a [=map=], then throw a {{TypeError}} indicating that the "`imports`" top-level key must be a JSON object.
    1. Set |sortedAndNormalizedImports| to the result of [=sorting and normalizing a specifier map=] given |parsed|["`imports`"] and |baseURL|.
  1. Let |sortedAndNormalizedScopes| be an empty [=map=].
  1. If |parsed|["`scopes`"] [=map/exists=], then:
    1. If |parsed|["`scopes`"] is not a [=map=], then throw a {{TypeError}} indicating that the "`scopes`" top-level key must be a JSON object.
    1. Set |sortedAndNormalizedScopes| to the result of [=sorting and normalizing scopes=] given |parsed|["`scopes`"] and |baseURL|.
  1. Return the [=/import map=] whose [=import map/imports=] are |sortedAndNormalizedImports| and whose [=import map/scopes=] scopes are |sortedAndNormalizedScopes|.
</div>

<div class="example" id="parsing-example">
  The [=/import map=] is a highly normalized structure. For example, given a base URL of `<https://example.com/base/page.html>`, the input

  <xmp highlight="json">
    {
      "imports": {
        "/app/helper": "node_modules/helper/index.mjs",
        "std:kv-storage": [
          "std:kv-storage",
          "node_modules/kv-storage-polyfill/index.mjs",
        ]
      }
    }
  </xmp>

  will generate an [=/import map=] with [=import map/imports=] of

  <xmp>
  «[
    "https://example.com/app/helper" → «
      <https://example.com/base/node_modules/helper/index.mjs>
    »,
    "std:kv-storage" → «
      <std:kv-storage>,
      <https://example.com/base/node_modules/kv-storage-polyfill/index.mjs>
    »
  ]»
  </xmp>

  and (despite nothing being present in the input) an empty [=map=] for its [=import map/scopes=].
</div>

<div algorithm>
  To <dfn lt="sort and normalize a specifier map|sorting and normalizing a specifier map">sort and normalize a specifier map</dfn>, given a [=map=] |originalMap| and a [=URL=] |baseURL|:

  1. Let |normalized| be an empty [=map=].
  1. First, normalize all [=map/entries=] so that their [=map/values=] are [=lists=]. [=map/For each=] |specifierKey| → |value| of |originalMap|,
    1. Let |normalizedSpecifierKey| be the result of [=normalizing a specifier key=] given |specifierKey| and |baseURL|.
    1. If |normalizedSpecifierKey| is null, then [=continue=].
    1. If |value| is a [=string=], then set |normalized|[|normalizedSpecifierKey|] to «|value|».
    1. Otherwise, if |value| is null, then set |normalized|[|normalizedSpecifierKey|] to a new empty list.
    1. Otherwise, if |value| is a [=list=], then set |normalized|[|normalizedSpecifierKey|] to |value|.
  1. Next, normalize and validate each potential address in the value [=lists=]. [=map/For each=] |specifierKey| → |potentialAddresses| of |normalized|,
    1. Assert: |potentialAddresses| is a [=list=], because of the previous normalization pass.
    1. Let |validNormalizedAddresses| be an empty [=list=].
    1. [=list/For each=] |potentialAddress| of |potentialAddresses|,
      1. If |potentialAddress| is not a [=string=], then [=continue=].
      1. Let |addressURL| be the result of [=parsing a URL-like import specifier=] given |potentialAddress| and |baseURL|.
      1. If |addressURL| is null, then [=continue=].
      1. If |specifierKey| ends with U+002F (/), and the [=URL serializer|serialization=] of |addressURL| does not end with U+002F (/), then:
        1. [=Report a warning to the console=] that an invalid target address was given for the specifier key |specifierKey|; since |specifierKey| ended in a slash, so must the address.
        1. [=Continue=].
      1. If |specifierKey|'s [=url/scheme=] is "`std`" and the [=URL serializer|serialization=] of |addressURL| contains U+002F (/), then:
        1. [=Report a warning to the console=] that built-in module URLs must not contain slashes.
        1. [=Continue=].
      1. [=list/Append=] |addressURL| to |validNormalizedAddresses|.
    1. Set |normalized|[|specifierKey|] to |validNormalizedAddresses|.
  1. Return the result of [=map/sorting=] |normalized|, with an entry |a| being less than an entry |b| if |a|'s [=map/key=] is [=longer or code unit less than=] |b|'s [=map/key=].
</div>

<div algorithm>
  To <dfn lt="sort and normalize scopes|sorting and normalizing scopes">sort and normalize scopes</dfn>, given a [=map=] |originalMap| and a [=URL=] |baseURL|:

  1. Let |normalized| be an empty [=map=].
  1. [=map/For each=] |scopePrefix| → |potentialSpecifierMap| of |originalMap|,
    1. If |potentialSpecifierMap| is not a [=map=], then throw a {{TypeError}} indicating that the value of the scope with prefix |scopePrefix| must be a JSON object.
    1. Let |scopePrefixURL| be the result of [=URL parser|parsing=] |scopePrefix| with |baseURL| as the base URL.
    1. If |scopePrefixURL| is failure, then [=continue=].
    1. If |scopePrefixURL|'s [=url/scheme=] is not a [=fetch scheme=], then:
      1. [=Report a warning to the console=] that scope prefix URLs must have a fetch scheme.
      1. [=Continue=].
    1. Let |normalizedScopePrefix| be the [=URL serializer|serialization=] of |scopePrefixURL|.
    1. Set |normalized|[|normalizedScopePrefix|] to the result of [=sorting and normalizing a specifier map=] given |potentialSpecifierMap| and |baseURL|.
  1. Return the result of [=map/sorting=] |normalized|, with an entry |a| being less than an entry |b| if |a|'s [=map/key=] is [=longer or code unit less than=] |b|'s [=map/key=].
</div>

<div algorithm>
  To <dfn lt="normalize a specifier key|normalizing a specifier key">normalize a specifier key</dfn>, given a [=string=] |specifierKey| and a [=URL=] |baseURL|:

  1. If |specifierKey| is the empty string, then return null.
  1. Let |url| be the result of [=parsing a URL-like import specifier=], given |specifierKey| and |baseURL|.
  1. If |url| is not null, then:
    1. Let |urlString| be the [=URL serializer|serialization=] of |url|.
    1. If |url|'s [=url/scheme=] is "`std`" and |urlString| contains U+002F (/), then:
      1. [=Report a warning to the console=] that built-in module specifiers must not contain slashes.
      1. Return null.
    1. Return |urlString|.
  1. Return |specifierKey|.
</div>

<div algorithm>
  To <dfn lt="parse a URL-like import specifier|parsing a URL-like import specifier">parse a URL-like import specifier</dfn>, given a [=string=] |specifier| and a [=URL=] |baseURL|:

  1. If |specifier| [=/starts with=] "`/`", "`./`", or "`../`", then return the result of [=URL parser|parsing=] |specifier| with |baseURL| as the base URL.
  1. Let |url| be the result of [=URL parser|parsing=] |specifier| (with no base URL).
  1. If |url| is failure, then return null.
  1. If |url|'s [=url/scheme=] is either a [=fetch scheme=] or "`std`", then return |url|.
  1. Return null.
</div>

<div algorithm>
  A [=string=] |a| is <dfn>longer or code unit less than</dfn> |b| if |a|'s [=string/length=] is greater than |b|'s [=string/length=], or if |a| is [=code unit less than=] |b|.
</div>

<h2 id="resolving">Resolving module specifiers</h2>

<div algorithm>
  HTML already has a <a spec="html">resolve a module specifier</a> algorithm. We replace it with the following <dfn export>resolve a module specifier</dfn> algorithm, given a [=script=] |referringScript| and a [=JavaScript string=] |specifier|:

  1. Let |importMap| be |referringScript|'s [=script/settings object=]'s [=environment settings object/import map=].
  1. Let |moduleMap| be |referringScript|'s [=script/settings object=]'s [=environment settings object/module map=].
  1. Let |scriptURL| be |referringScript|'s [=script/base URL=].
  1. Let |scriptURLString| be |scriptURL|, [=URL serializer|serialized=].
  1. Let |asURL| be the result of [=parsing a URL-like import specifier=] given |specifier| and |scriptURL|.
  1. Let |normalizedSpecifier| be the [=URL serializer|serialization=] of |asURL|, if |asURL| is non-null; otherwise, |specifier|.
  1. [=map/For each=] |scopePrefix| → |scopeImports| of |importMap|'s [=import map/scopes=],
    1. If |scopePrefix| is |scriptURLString|, or if |scopePrefix| ends with U+002F (/) and |scriptURLString| [=/starts with=] |scopePrefix|, then:
      1. Let |scopeImportsMatch| be the result of [=resolving an imports match=] given |normalizedSpecifier|, |scopeImports|, and |moduleMap|.
      1. If |scopeImportsMatch| is not null, then return |scopeImportsMatch|.
  1. Let |topLevelImportsMatch| be the reuslt of [=resolving an imports match=] given |normalizedSpecifier|, |importMap|'s [=import map/imports=], and |moduleMap|.
  1. If |topLevelImportsMatch| is not null, then return |topLevelImportsMatch|.
  1. <p class="note">At this point, the specifier was able to be turned in to a URL, but it wasn't remapped to anything by |importMap|.</p>
    If |asURL| is not null, then:
    1. If |asURL|'s [=url/scheme=] is "`std`", and |moduleMap|[|asURL|] does not [=map/exist=], then throw a {{TypeError}} indicating that the requested built-in module is not implemented.
    1. Return |asURL|.
  1. Throw a {{TypeError}} indicating that |specifier| was a bare specifier, but was not remapped to anything by |importMap|.
</div>

<p class="advisement">It seems possible that the return type could end up being a [=list=] of [=URLs=], not just a single URL, to support HTTPS → HTTPS fallback. But, we haven't gotten that far yet; for now let's assume it stays a single URL.</p>

All call sites of HTML's existing <a spec="html">resolve a module specifier</a> will need to be updated to pass the appropriate [=script=], not just its [=script/base URL=].

They will also need to be updated to account for it now throwing exceptions, instead of returning failure. (Previously they just turned failures into {{TypeError}}s manually, so this is straightforward.)

<div algorithm>
  To <dfn lt="resolve an imports match|resolving an imports match">resolve an imports match</dfn>, given a [=string=] |normalizedSpecifier|, a [=specifier map=] |specifierMap|, and a [=module map=] |moduleMap|:

  1. For each |specifierKey| → |addresses| of |specifierMap|,
    1. If |specifierKey| is |normalizedSpecifier|, then:
      1. If |addresses|'s [=list/size=] is 0, then throw a {{TypeError}} indicating that |normalizedSpecifier| was mapped to no addresses.
      1. If |addresses|'s [=list/size=] is 1, then:
        1. Let |singleAddress| be |addresses|[0].
        1. If |singleAddress|'s [=url/scheme=] is "`std`", and |moduleMap|[|singleAddress|] does not [=map/exist=], then throw a {{TypeError}} indicating that the requested built-in module is not implemented.
        1. Return |singleAddress|.
      1. If |addresses|'s [=list/size=] is 2, and |addresses|[0]'s [=url/scheme=] is "`std`", and |addresses|[1]'s [=url/scheme=] is <em>not</em> "`std`", then:
        1. Return |addresses|[0], if |moduleMap|[|addresses|[0]] [=map/exists=]; otherwise, return |addresses|[1].
      1. Otherwise, <span class="advisement">we have no specification for more complicated fallbacks yet; throw a {{TypeError}} indicating this is not yet supported</span>.
    1. If |specifierKey| ends with U+002F (/) and |normalizedSpecifier| [=/starts with=] |specifierKey|, then:
      1. If |addresses|'s [=list/size=] is 0, then throw a {{TypeError}} indicating that |normalizedSpecifier| was mapped to no addresses.
      1. If |addresses|'s [=list/size=] is 1, then:
        1. Let |afterPrefix| be the portion of |normalizedSpecifier| after the initial |specifierKey| prefix.
        1. Let |url| be the result of [=URL parser|parsing=] |afterPrefix| relative to |addresses|[0].
        1. If |url| is failure, throw a {{TypeError}}, implicating |normalizedSpecifier| (and in particular the |afterPrefix| portion).
        1. Return |url|.
      1. Otherwise, <span class="advisement">we have no specification for more complicated fallbacks yet; throw a {{TypeError}} indicating this is not yet supported</span>.
</div>
