<pre class="metadata">
Title: Import Maps
Shortname: import-maps
Repository: WICG/import-maps
Inline Github Issues: true
Group: WICG
Status: ED
Level: 1
URL: https://wicg.github.io/import-maps/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: Import maps allow web pages to control the behavior of JavaScript imports, and introduce a new <code>import:</code> URL scheme to allow using this mapping in other URL-accepting contexts
!Participate: <a href="https://github.com/WICG/import-maps">GitHub WICG/import-maps</a> (<a href="https://github.com/WICG/import-maps/issues/new">new issue</a>, <a href="https://github.com/WICG/import-maps/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/import-maps/commits/master/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
</pre>
<pre class="link-defaults">
spec: infra; type: dfn
  text: string
  text: list
spec: url; type: dfn; for: /; text: url
spec: infra; type: dfn; for:/; text: starts with
spec: html; type: element; text: script
</pre>
<pre class="anchors">
spec: html; type: dfn; urlPrefix: https://html.spec.whatwg.org/multipage/
  text: module map; for: /; url: webappapis.html#module-map
  text: fetch an import() module script graph; url: webappapis.html#fetch-an-import()-module-script-graph
  text: fetch a modulepreload module script graph; url: webappapis.html#fetch-a-modulepreload-module-script-graph
  text: fetch an inline module script graph; url: webappapis.html#fetch-an-inline-module-script-graph
  text: script; url: webappapis.html#concept-script
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

summary {
  cursor: pointer;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="definitions">Definitions</h2>

A <dfn>specifier map</dfn> is an [=ordered map=] from [=strings=] to [=lists=] of [=URLs=].

A <dfn>import map</dfn> is a [=struct=] with two [=struct/items=]:

* <dfn for="import map">imports</dfn>, a [=specifier map=], and
* <dfn for="import map">scopes</dfn>, an [=ordered map=] of [=URLs=] to [=specifier maps=].

An <dfn>empty import map</dfn> is an [=/import map=] with its [=import map/imports=] and [=import map/scopes=] both being empty maps.

<div algorithm>
  To <dfn>update an import map</dfn> |import map| with a second [=/import map=] |new import map|:

  1. Assert: |import map| is not null.
  1. Assert: |new import map| is not null.
  1. <p class="note">TODO: Implement merging. This merges |new import map| into |import map| and thus updates |import map| in-place.</p>
</div>

<h2 id="acquiring">Acquiring import maps</h2>

<h3 id="integration-environment-settings-object">New members of environment settings object</h3>

Each [=environment settings object=] will get an <dfn for="environment settings object">import map</dfn> algorithm, which returns an [=/import map=] created by parsing and merging all `<script type="importmap">` elements that are encountered (before the cutoff).

A {{Document}} has an [=/import map=] <dfn for="Document">import map</dfn>. It is initially a new [=/empty import map=].

In <a spec="html">set up a window environment settings object</a>, <var ignore>settings object</var>'s [=environment settings object/import map=] returns the [=Document/import map=] of <var ignore>window</var>'s <a>associated <code>Document</code></a>.

A {{WorkerGlobalScope}} has an [=/import map=] <dfn for="WorkerGlobalScope">import map</dfn>. It is initially a new [=/empty import map=].

ISSUE: Specify a way to set {{WorkerGlobalScope}}'s [=WorkerGlobalScope/import map=]. We might want to inherit parent context's import maps, or provide APIs on {{WorkerGlobalScope}}, but we are not sure. Currently it is always an [=/empty import map=]. See <a href="https://github.com/WICG/import-maps/issues/2">#2</a>.</p>

In <a spec="html">set up a worker environment settings object</a>, <var ignore>settings object</var>'s [=environment settings object/import map=] returns <var ignore>worker global scope</var>'s [=WorkerGlobalScope/import map=].

<p class="note">
  This infrastructure is very similar to the existing specification for module maps.
</p>

Each [=environment settings object=] has a <dfn for="environment settings object">pending import maps count</dfn>, which is an integer. It is initially 0.

Each [=environment settings object=] has an <dfn for="environment settings object">acquiring import maps</dfn> boolean. It is initially true.

<p class="note">
  These two pieces of state are used to achieve the following behavior:

  <ul>
    <li>Import maps are accepted if and only if they are added (i.e., their corresponding <{script}> elements are added) before the first module load is started, even if the loading of the import map files don't finish before the first module load is started.
    <li>Module loading waits for any import maps that have already started loading, if any.
  </ul>
</p>

<h3 id="integration-prepare-a-script">Prepare a script</h3>

- <a spec="html">the script's type</a> should be:
  - which is either "classic", "module", or "`importmap`".
    <p class="note">Although we add the new script type, we don't add the new subclass of [=script=]. Import maps are processed outside the existing paths for [=scripts=] and <a spec="html">execute a script block</a>, because the mechanism controlling the orders/dependencies between import map registration and script evaluation is quite separeted and different from the mechanism for controlling script evaluation order.</p>
- Insert the following step to [=prepare a script=] step 7, under "Determine the script's type as follows:":
  - If the script block's type string is an [=ASCII case-insensitive=] match for the string "`importmap`", <a spec="html">the script's type</a> is "`importmap`".
- Insert the following step before <a spec="html">prepare a script</a> step 24:
  - If <a spec="html">the script's type</a> is "`importmap`" and |settings object|'s [=environment settings object/acquiring import maps=] is false, then <a spec="html">queue a task</a> to <a spec="html">fire an event</a> named `error` at the element, and return.
    <p class="note">Alternative considered: We can proceed to import map loading if the [=environment settings object/pending import maps count=] isn't 0, even when [=environment settings object/acquiring import maps=] is false, because at that time subsequent module loading is blocked and new import map loads could be still added. This would allow a few more opportinities for adding import maps, but this would highly depend on the timing of network loading. For example, if the preceding import map load finishes earlier than expected, then subsequent import maps depending on this behavior might fail. To avoid this kind of nondeterminism, we didn't choose this option, at least for now.</p>
- Insert the following before <a spec="html">prepare a script</a> step 24.6:
  - If <a spec="html">the script's type</a> is "`importmap`", then:
    1. Increment |settings object|'s [=environment settings object/pending import maps count=].
    1. <a>Fetch an import map</a> given <var ignore>url</var>, |settings object|, and <var ignore>options</var>.
    1. When the previous step asynchronously completes with |result|:
       1. Decrement |settings object|'s [=environment settings object/pending import maps count=].
          <p class="note">If this decreases the [=environment settings object/pending import maps count=] to 0, it will (asynchronously) unblock any [=wait for import maps=] algorithm instances.</p>
       1. [=Register an import map=] given |result|, |settings object|, |base URL|, and the element.
    1. Return.
- Insert the following before <a spec="html">prepare a script</a> step 25.2:
  - If <a spec="html">the script's type</a> is "`importmap`", then:
    1. [=Register an import map=] given <var ignore>source text</var>, |settings object|, |base URL|, and the element.
    1. Return.

<p class="issue">CSP is applied to import maps just like JavaScript scripts. Is this sufficient? <a href="https://github.com/WICG/import-maps/issues/105">#105</a>.</p>

<p class="note">For import maps, the script never becomes <a spec="html" lt="the script is ready">ready</a> and <a spec="html">the script's script</a> remains null.</p>

<div algorithm>
  To <dfn export>fetch an import map</dfn> given <var ignore>url</var>, <var ignore>settings object</var>, and <var ignore>options</var>:

  1. <p class="note">TODO: Implement external import map fetching. This asynchronously returns a string or a failure.</p>

  <p class="note">CSP is to be applied in the Fetch spec.</p>
</div>

<h3 id="integration-wait-for-import-maps">Wait for import maps</h3>

<div algorithm>
  To <dfn export>wait for import maps</dfn> given |settings object|:

  1. Set |settings object|'s [=environment settings object/acquiring import maps=] to false.
  1. <a spec="html">Spin the event loop</a> until |settings object|'s [=environment settings object/pending import maps count=] is 0.
  1. Asynchronously complete this algorithm.
</div>

Insert a call to [=wait for import maps=] at the beginning of the following HTML spec concepts.

- [=fetch an external module script graph=]
- [=fetch an import() module script graph=]
- [=fetch a modulepreload module script graph=]
- [=fetch an inline module script graph=]
- [=fetch a module worker script graph=] (using <var ignore>module map settings object</var>)

<div class="advisement">
  In this draft of the spec, which inserts itself into these HTML concepts, the settings object used here is the |module map settings object|, not |fetch client settings object|, because [=resolve a module specifier=] uses the import map of |module map settings object|. In a potential future version of the import maps infrastructure, which interjects itself at the layer of the Fetch spec in order to support `import:` URLs, we would instead use |fetch client settings object|.

  This only affects [=fetch a module worker script graph=], where these two settings objects are different. And, given that the import maps for {{WorkerGlobalScope}}s are currently always empty, the only fetch that could be impacted is that of the initial module. But even that would not be impacted, because that fetch is done using URLs, not specifiers. So this is not a future compatibility hazard, just something to keep in mind as we develop import maps in module workers.
</div>

<p class="advisement">Depending on the exact location of [=wait for import maps=], there would be observable behavior differences between HTML-spec- and Fetch-spec-based import maps. For example, the current HTML-spec-based draft here calls [=wait for import maps=] at very early stages of module loading before [=resolve a module specifier=]. Therefore, [=environment settings object/acquiring import maps=] is always set back to false, even if [=resolve a module specifier=] fails e.g. in parsing `http://:invalid`. When we switch to Fetch-spec-based, import map resolution would be done inside Fetch spec after [=resolve a module specifier=] and thus we might also want to [=wait for import maps=] after [=resolve a module specifier=]. In that case, [=environment settings object/acquiring import maps=] wouldn't be reset to false for `http://:invalid`, because we early-exit module loading. </p>

<h3 id="integration-register-an-import-map">Registering an import map</h3>

<div algorithm>
To <dfn>register an import map</dfn> given a [=string=] or a null |source text|, an [=environment settings object=] |settings object|, a [=URL=] |base URL|, and an {{HTMLScriptElement}} |element|:

1. If |source text| is null, then [=queue a task=] to [=fire an event=] named `error` at |element|, and return.
1. If |element|'s <a spec="html">node document</a>'s <a spec="html">relevant settings object</a> is not equal to |settings object|, then return.
   <p class="note">This is spec'ed consistently with <a href="https://github.com/whatwg/html/pull/2673">whatwg/html#2673</a>.</p>
   <p class="advisement">Currently we don't fire `error` events in this case. If we change the decision at <a href="https://github.com/whatwg/html/pull/2673">whatwg/html#2673</a> to fire `error` events, then we should change this step accordingly.</p>
1. Let |import map| be the result of [=parsing an import map string=], given |source text| and |base URL|.
1. If |import map| is null, then [=queue a task=] to [=fire an event=] named `error` at |element|, and return.
1. Otherwise, [=update an import map|update=] |element|'s [=node document=]'s [=Document/import map=] with |import map|.

</div>

<h2 id="parsing">Parsing import maps</h2>

<div algorithm>
  To <dfn lt="parse an import map string|parsing an import map string">parse an import map string</dfn>, given a [=string=] |input| and a [=URL=] |baseURL|:

  1. Let |parsed| be the result of [=parse JSON into Infra values|parsing JSON into Infra values=] given |input|.
  1. If |parsed| is not a [=map=], then throw a {{TypeError}} indicating that the top-level value must be a JSON object.
  1. Let |sortedAndNormalizedImports| be an empty [=map=].
  1. If |parsed|["`imports`"] [=map/exists=], then:
    1. If |parsed|["`imports`"] is not a [=map=], then throw a {{TypeError}} indicating that the "`imports`" top-level key must be a JSON object.
    1. Set |sortedAndNormalizedImports| to the result of [=sorting and normalizing a specifier map=] given |parsed|["`imports`"] and |baseURL|.
  1. Let |sortedAndNormalizedScopes| be an empty [=map=].
  1. If |parsed|["`scopes`"] [=map/exists=], then:
    1. If |parsed|["`scopes`"] is not a [=map=], then throw a {{TypeError}} indicating that the "`scopes`" top-level key must be a JSON object.
    1. Set |sortedAndNormalizedScopes| to the result of [=sorting and normalizing scopes=] given |parsed|["`scopes`"] and |baseURL|.
  1. Return the [=/import map=] whose [=import map/imports=] are |sortedAndNormalizedImports| and whose [=import map/scopes=] scopes are |sortedAndNormalizedScopes|.
</div>

<div class="example" id="parsing-example">
  The [=/import map=] is a highly normalized structure. For example, given a base URL of `<https://example.com/base/page.html>`, the input

  <xmp highlight="json">
    {
      "imports": {
        "/app/helper": "node_modules/helper/index.mjs",
        "std:kv-storage": [
          "std:kv-storage",
          "node_modules/kv-storage-polyfill/index.mjs",
        ]
      }
    }
  </xmp>

  will generate an [=/import map=] with [=import map/imports=] of

  <xmp>
  «[
    "https://example.com/app/helper" → «
      <https://example.com/base/node_modules/helper/index.mjs>
    »,
    "std:kv-storage" → «
      <std:kv-storage>,
      <https://example.com/base/node_modules/kv-storage-polyfill/index.mjs>
    »
  ]»
  </xmp>

  and (despite nothing being present in the input) an empty [=map=] for its [=import map/scopes=].
</div>

<div algorithm>
  To <dfn lt="sort and normalize a specifier map|sorting and normalizing a specifier map">sort and normalize a specifier map</dfn>, given a [=map=] |originalMap| and a [=URL=] |baseURL|:

  1. Let |normalized| be an empty [=map=].
  1. First, normalize all [=map/entries=] so that their [=map/values=] are [=lists=]. [=map/For each=] |specifierKey| → |value| of |originalMap|,
    1. Let |normalizedSpecifierKey| be the result of [=normalizing a specifier key=] given |specifierKey| and |baseURL|.
    1. If |normalizedSpecifierKey| is null, then [=continue=].
    1. If |value| is a [=string=], then set |normalized|[|normalizedSpecifierKey|] to «|value|».
    1. Otherwise, if |value| is null, then set |normalized|[|normalizedSpecifierKey|] to a new empty list.
    1. Otherwise, if |value| is a [=list=], then set |normalized|[|normalizedSpecifierKey|] to |value|.
  1. Next, normalize and validate each potential address in the value [=lists=]. [=map/For each=] |specifierKey| → |potentialAddresses| of |normalized|,
    1. Assert: |potentialAddresses| is a [=list=], because of the previous normalization pass.
    1. Let |validNormalizedAddresses| be an empty [=list=].
    1. [=list/For each=] |potentialAddress| of |potentialAddresses|,
      1. If |potentialAddress| is not a [=string=], then [=continue=].
      1. Let |addressURL| be the result of [=parsing a URL-like import specifier=] given |potentialAddress| and |baseURL|.
      1. If |addressURL| is null, then [=continue=].
      1. If |specifierKey| ends with U+002F (/), and the [=URL serializer|serialization=] of |addressURL| does not end with U+002F (/), then:
        1. [=Report a warning to the console=] that an invalid target address was given for the specifier key |specifierKey|; since |specifierKey| ended in a slash, so must the address.
        1. [=Continue=].
      1. If |specifierKey|'s [=url/scheme=] is "`std`" and the [=URL serializer|serialization=] of |addressURL| contains U+002F (/), then:
        1. [=Report a warning to the console=] that built-in module URLs must not contain slashes.
        1. [=Continue=].
      1. [=list/Append=] |addressURL| to |validNormalizedAddresses|.
    1. Set |normalized|[|specifierKey|] to |validNormalizedAddresses|.
  1. Return the result of [=map/sorting=] |normalized|, with an entry |a| being less than an entry |b| if |a|'s [=map/key=] is [=longer or code unit less than=] |b|'s [=map/key=].
</div>

<div algorithm>
  To <dfn lt="sort and normalize scopes|sorting and normalizing scopes">sort and normalize scopes</dfn>, given a [=map=] |originalMap| and a [=URL=] |baseURL|:

  1. Let |normalized| be an empty [=map=].
  1. [=map/For each=] |scopePrefix| → |potentialSpecifierMap| of |originalMap|,
    1. If |potentialSpecifierMap| is not a [=map=], then throw a {{TypeError}} indicating that the value of the scope with prefix |scopePrefix| must be a JSON object.
    1. Let |scopePrefixURL| be the result of [=URL parser|parsing=] |scopePrefix| with |baseURL| as the base URL.
    1. If |scopePrefixURL| is failure, then [=continue=].
    1. If |scopePrefixURL|'s [=url/scheme=] is not a [=fetch scheme=], then:
      1. [=Report a warning to the console=] that scope prefix URLs must have a fetch scheme.
      1. [=Continue=].
    1. Let |normalizedScopePrefix| be the [=URL serializer|serialization=] of |scopePrefixURL|.
    1. Set |normalized|[|normalizedScopePrefix|] to the result of [=sorting and normalizing a specifier map=] given |potentialSpecifierMap| and |baseURL|.
  1. Return the result of [=map/sorting=] |normalized|, with an entry |a| being less than an entry |b| if |a|'s [=map/key=] is [=longer or code unit less than=] |b|'s [=map/key=].
</div>

<div algorithm>
  To <dfn lt="normalize a specifier key|normalizing a specifier key">normalize a specifier key</dfn>, given a [=string=] |specifierKey| and a [=URL=] |baseURL|:

  1. If |specifierKey| is the empty string, then return null.
  1. Let |url| be the result of [=parsing a URL-like import specifier=], given |specifierKey| and |baseURL|.
  1. If |url| is not null, then:
    1. Let |urlString| be the [=URL serializer|serialization=] of |url|.
    1. If |url|'s [=url/scheme=] is "`std`" and |urlString| contains U+002F (/), then:
      1. [=Report a warning to the console=] that built-in module specifiers must not contain slashes.
      1. Return null.
    1. Return |urlString|.
  1. Return |specifierKey|.
</div>

<div algorithm>
  To <dfn lt="parse a URL-like import specifier|parsing a URL-like import specifier">parse a URL-like import specifier</dfn>, given a [=string=] |specifier| and a [=URL=] |baseURL|:

  1. If |specifier| [=/starts with=] "`/`", "`./`", or "`../`", then return the result of [=URL parser|parsing=] |specifier| with |baseURL| as the base URL.
  1. Let |url| be the result of [=URL parser|parsing=] |specifier| (with no base URL).
  1. If |url| is failure, then return null.
  1. If |url|'s [=url/scheme=] is either a [=fetch scheme=] or "`std`", then return |url|.
  1. Return null.
</div>

<div algorithm>
  A [=string=] |a| is <dfn>longer or code unit less than</dfn> |b| if |a|'s [=string/length=] is greater than |b|'s [=string/length=], or if |a| is [=code unit less than=] |b|.
</div>

<h2 id="resolving">Resolving module specifiers</h2>

<div algorithm>
  HTML already has a <a spec="html">resolve a module specifier</a> algorithm. We replace it with the following <dfn export>resolve a module specifier</dfn> algorithm, given a [=script=] |referringScript| and a [=JavaScript string=] |specifier|:

  1. Let |importMap| be |referringScript|'s [=script/settings object=]'s [=environment settings object/import map=].
  1. Let |moduleMap| be |referringScript|'s [=script/settings object=]'s [=environment settings object/module map=].
  1. Let |scriptURL| be |referringScript|'s [=script/base URL=].
  1. Let |scriptURLString| be |scriptURL|, [=URL serializer|serialized=].
  1. Let |asURL| be the result of [=parsing a URL-like import specifier=] given |specifier| and |scriptURL|.
  1. Let |normalizedSpecifier| be the [=URL serializer|serialization=] of |asURL|, if |asURL| is non-null; otherwise, |specifier|.
  1. [=map/For each=] |scopePrefix| → |scopeImports| of |importMap|'s [=import map/scopes=],
    1. If |scopePrefix| is |scriptURLString|, or if |scopePrefix| ends with U+002F (/) and |scriptURLString| [=/starts with=] |scopePrefix|, then:
      1. Let |scopeImportsMatch| be the result of [=resolving an imports match=] given |normalizedSpecifier|, |scopeImports|, and |moduleMap|.
      1. If |scopeImportsMatch| is not null, then return |scopeImportsMatch|.
  1. Let |topLevelImportsMatch| be the reuslt of [=resolving an imports match=] given |normalizedSpecifier|, |importMap|'s [=import map/imports=], and |moduleMap|.
  1. If |topLevelImportsMatch| is not null, then return |topLevelImportsMatch|.
  1. <p class="note">At this point, the specifier was able to be turned in to a URL, but it wasn't remapped to anything by |importMap|.</p>
    If |asURL| is not null, then:
    1. If |asURL|'s [=url/scheme=] is "`std`", and |moduleMap|[|asURL|] does not [=map/exist=], then throw a {{TypeError}} indicating that the requested built-in module is not implemented.
    1. Return |asURL|.
  1. Throw a {{TypeError}} indicating that |specifier| was a bare specifier, but was not remapped to anything by |importMap|.
</div>

<p class="advisement">It seems possible that the return type could end up being a [=list=] of [=URLs=], not just a single URL, to support HTTPS → HTTPS fallback. But, we haven't gotten that far yet; for now let's assume it stays a single URL.</p>

All call sites of HTML's existing <a spec="html">resolve a module specifier</a> will need to be updated to pass the appropriate [=script=], not just its [=script/base URL=].

They will also need to be updated to account for it now throwing exceptions, instead of returning failure. (Previously they just turned failures into {{TypeError}}s manually, so this is straightforward.)

<div algorithm>
  To <dfn lt="resolve an imports match|resolving an imports match">resolve an imports match</dfn>, given a [=string=] |normalizedSpecifier|, a [=specifier map=] |specifierMap|, and a [=module map=] |moduleMap|:

  1. For each |specifierKey| → |addresses| of |specifierMap|,
    1. If |specifierKey| is |normalizedSpecifier|, then:
      1. If |addresses|'s [=list/size=] is 0, then throw a {{TypeError}} indicating that |normalizedSpecifier| was mapped to no addresses.
      1. If |addresses|'s [=list/size=] is 1, then:
        1. Let |singleAddress| be |addresses|[0].
        1. If |singleAddress|'s [=url/scheme=] is "`std`", and |moduleMap|[|singleAddress|] does not [=map/exist=], then throw a {{TypeError}} indicating that the requested built-in module is not implemented.
        1. Return |singleAddress|.
      1. If |addresses|'s [=list/size=] is 2, and |addresses|[0]'s [=url/scheme=] is "`std`", and |addresses|[1]'s [=url/scheme=] is <em>not</em> "`std`", then:
        1. Return |addresses|[0], if |moduleMap|[|addresses|[0]] [=map/exists=]; otherwise, return |addresses|[1].
      1. Otherwise, <span class="advisement">we have no specification for more complicated fallbacks yet; throw a {{TypeError}} indicating this is not yet supported</span>.
    1. If |specifierKey| ends with U+002F (/) and |normalizedSpecifier| [=/starts with=] |specifierKey|, then:
      1. If |addresses|'s [=list/size=] is 0, then throw a {{TypeError}} indicating that |normalizedSpecifier| was mapped to no addresses.
      1. If |addresses|'s [=list/size=] is 1, then:
        1. Let |afterPrefix| be the portion of |normalizedSpecifier| after the initial |specifierKey| prefix.
        1. Let |url| be the result of [=URL parser|parsing=] |afterPrefix| relative to |addresses|[0].
        1. If |url| is failure, throw a {{TypeError}}, implicating |normalizedSpecifier| (and in particular the |afterPrefix| portion).
        1. Return |url|.
      1. Otherwise, <span class="advisement">we have no specification for more complicated fallbacks yet; throw a {{TypeError}} indicating this is not yet supported</span>.
</div>
